---
layout: post
title: 📔【操作系统】Copy-on-write（COW）机制
date: 2019/11/15 15:00
---

参考资料
* https://juejin.im/post/5bd96bcaf265da396b72f855
* https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html

## 为什么要学 COW
很多工具都用到，比如 redis 都 bgsave（TODO，补充详细）

## 简介
COW 也称为

### fork() 和 exec()
fork()：
* fork 用于创建子进程

exec()：
* exec() 并不是一个特定的函数, 它是一组函数的统称
* 装载**一个新的程序**（可执行映像）直接替换掉**当前进程的地址空间**，从而执行不同的任务

## 虚拟内存空间

传统 fork（）：
* 将父进程的数据拷贝到子进程中
* 父进程和子进程之间的数据段和堆栈是相互独立的
* 子进程 P2 新建一个结构体，复制一份数据段/堆栈段，但是代码段继续共享父进程的物理空间（两者的代码完全相同）

![](/media/15883240927671.jpg)

但是，以我们的使用经验来说：往往子进程都会执行exec()来做自己想要实现的功能。所以，如果按照上面的做法的话，创建子进程时复制过去的数据是没用的(因为子进程执行exec()，原有的数据会被清空)。于是就有了 COW 技术。
> 通常，该进程不会修改任何内存，而是立即执行一个新进程，从而完全替换地址空间。因此，在派生期间复制所有进程的内存是浪费的，而是使用写时复制技术。

写时复制（COW，copy on write）：
* 父子进程获取相同的指针指向相同的资源，共享内存空间
* 当某个调用者试图修改资源的内容时，系统会真正复制一份专用副本（private copy）给该调用者
* 此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建。因此多个调用者只是读取操作时，可以共享同一份资源，节省了开销
* 只为子进程 P2 新建一个结构体，但是**和父进程指向同样的物理空间**。当父子进程中**有更改相应段的行为发生时**，再为**子进程相应的段分配物理空间**

![](/media/15883243223396.jpg)

只为子进程 P2 新建一个结构体，但是和父进程指向同样的物理空间。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。

vfork()：子进程直接使用父进程的结构体。
![](/media/15883243998673.jpg)

## 原理
Copy On Write技术实现原理：

fork() 之后，kernel 把父进程中所有的内存页的权限都设为 read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU 硬件检测到内存页是 read-only 的，于是触发页异常中断（page-fault），陷入 kernel 的一个中断例程。中断例程中，kernel 就会把**触发的异常的页**复制一份，于是父子进程各自持有独立的一份。

可以使用页表有效地实现写时复制：通过将某些内存页面标记为只读并保留对该页面的引用数。当将数据写入这些页面时，内核将拦截写入并尝试分配一个新的物理页面，该页面将使用写时复制数据进行初始化，但是如果只有一个引用，则可以跳过分配。然后，内核使用新的（可写的）页面更新页面表（增加页表项），减少引用数，然后执行写操作。新分配可确保一个进程的内存更改在另一进程中不可见。

## 优缺点
Copy On Write 技术好处是什么？

COW 技术可减少分配和复制大量资源时带来的瞬间延时。（redis 用到了吗？见下文）
COW 技术可减少不必要的资源分配。比如 fork 进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。

Copy On Write 技术缺点是什么？

如果在 fork() 之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断 page-fault)，这种频繁的陷入内核会带来额外的开销，效率变低，得不偿失。

## 使用
### Redis 中的使用
Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那Redis会fork出一个子进程来读取数据，从而写到磁盘中。

总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的分页错误(页异常中断page-fault)，这样就得耗费不少性能在复制上。

而在rehash阶段上，写操作是无法避免的。所以Redis在fork出子进程之后，将负载因子阈值提高，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存

TODO：这里并不完善，需要再补充细节。

### 动态链接器 共享内存
加载应用程序的库也是使用写时复制技术。动态链接器将库映射为私有库，如下所示。对库的任何写操作都将触发虚拟内存管理中的COW。
```c
openat(AT_FDCWD, "/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
mmap(NULL, 3906144, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0)
mmap(0x7f8a3ced4000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000)
```

### 软件中：多线程
在多线程系统中，可以在不使用传统锁的情况下实现 COW，使用 CAS 来增加或减少内部参考计数器。由于原始资源永远不会改变，因此可以安全地由多个线程复制（在增加引用计数之后），而无需诸如 mutex（互斥锁）之类的性能昂贵的锁。如果引用计数器变为0，则根据定义，只有1个线程持有该引用，因此可以安全地从内存中取消分配资源，同样无需使用性能昂贵的锁机制。

因此，不必复制资源的好处（与传统的深层复制相比，所带来的性能提升）在单线程和多线程系统中都是有效的。

例子：C++ STL 的 string 在最初 C++ 98 标准下允许 COW 的实现，不过 C++ 11 标准中没有。

TODO: 细节

```c++
std::string x("Hello");

std::string y = x;  // x and y use the same buffer

y += ", World!";    // now y uses a different buffer
                    // x still uses the same old buffer
```


在PHP编程语言中，除引用外的所有类型均实现为写时复制。例如，字符串和数组通过引用传递，但是在修改后，如果它们的引用计数非零，则它们将复制。这使它们可以充当值类型（values type），而不会在其赋值时复制或使其不可修改时出现性能问题。

### 文件系统
Copy-on-write 在对数据进行修改的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改，这样的好处是一旦系统突然断电，重启之后不需要做Fsck。好处就是能保证数据的完整性，掉电的话容易恢复。

比如说：要修改数据块A的内容，先把 A 读出来，写到B块里面去。如果这时候断电了，原来 A 的内容还在！

TODO：
* [文件系统中的 copy-on-write 模式有什么具体的好处](https://www.zhihu.com/question/19782224/answers/created)
* [新一代 Linux 文件系统 btrfs 简介](https://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/)