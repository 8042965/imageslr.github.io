---
layout: post
title: 📔【操作系统】Copy-on-write（COW）机制
date: 2019/11/15 15:00
---

参考资料
* https://juejin.im/post/5bd96bcaf265da396b72f855
* https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html

## 简介
### fork() 和 exec()
fork()：
* fork 用于创建子进程

exec()：
* exec() 并不是一个特定的函数, 它是一组函数的统称
* 装载**一个新的程序**（可执行映像）直接替换掉**当前进程的地址空间**，从而执行不同的任务

## 虚拟内存空间

传统 fork（）：
* 将父进程的数据拷贝到子进程中
* 父进程和子进程之间的数据段和堆栈是相互独立的
* 子进程 P2 新建一个结构体，复制一份数据段/堆栈段，但是代码段继续共享父进程的物理空间（两者的代码完全相同）

![](/media/15883240927671.jpg)


写时复制（COW，copy on write）：
* 父子进程获取相同的指针指向相同的资源，共享内存空间
* 当某个调用者试图修改资源的内容时，系统会真正复制一份专用副本（private copy）给该调用者
* 此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建。因此多个调用者只是读取操作时，可以共享同一份资源，节省了开销
* 只为子进程 P2 新建一个结构体，但是**和父进程指向同样的物理空间**。当父子进程中**有更改相应段的行为发生时**，再为**子进程相应的段分配物理空间**

![](/media/15883243223396.jpg)
只为子进程 P2 新建一个结构体，但是和父进程指向同样的物理空间。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。

vfork()：子进程直接使用父进程的结构体。
![](/media/15883243998673.jpg)

## 原理
Copy On Write技术实现原理：

fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。

## 优缺点
Copy On Write技术好处是什么？

COW技术可减少分配和复制大量资源时带来的瞬间延时。
COW技术可减少不必要的资源分配。比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。

Copy On Write技术缺点是什么？

如果在fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断page-fault)，这样就得不偿失。


## Redis 中的使用
Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那Redis会fork出一个子进程来读取数据，从而写到磁盘中。
总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的分页错误(页异常中断page-fault)，这样就得耗费不少性能在复制上。
而在rehash阶段上，写操作是无法避免的。所以Redis在fork出子进程之后，将负载因子阈值提高，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存

TODO：这里并不完善，需要再补充细节。

## 文件系统的 COW
文件系统的COW
下面来看看文件系统中的COW是啥意思：
Copy-on-write在对数据进行修改的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改，这样的好处是一旦系统突然断电，重启之后不需要做Fsck。好处就是能保证数据的完整性，掉电的话容易恢复。

比如说：要修改数据块A的内容，先把A读出来，写到B块里面去。如果这时候断电了，原来A的内容还在！

TODO：
* [文件系统中的 copy-on-write 模式有什么具体的好处](https://www.zhihu.com/question/19782224/answers/created)
* [新一代 Linux 文件系统 btrfs 简介](https://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/)