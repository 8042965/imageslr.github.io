---
layout: post
title: 📔【深入理解计算机系统】如何表示最大、最小的整数
date: 2019/12/21 11:00
---

## 最大、最小整数的二进制表示
> 深入了解数字的二进制表示，请查看：[📔【深入理解计算机系统】第 2 章：信息的处理与表示]({% post_url 2019-11-30-csapp-2 %}#整数表示)

计算机中的数字表示分为无符号数与有符号数。以 32 位整数为例，对于无符号数，最小值自然是**所有位全为 0**，写成十六进制即 `0x00000000`；最大值是**所有位全为 1**，写成十六进制即 `0xffffffff`，相当于 $2^{32}-1$ == `4294967295`。

对于有符号数，最高位是符号位。符号位为 0 表示正数，为 1 表示负数。因此有符号数的最大值是“**符号位为 0、剩余位全 1**”的正数，写成十六进制即 `0x7fffffff`，相当于 $2^{31}-1$ == `2147483647`。
```
0111 1111 1111 1111 1111 1111 1111 1111 # 二进制
7    f    f    f    f    f    f    f    # 十六进制
```

有符号数的最小值是“**符号位为 1、剩余位全 0**”的负数，写成十六进制即 `0x80000000`，相当于 $-2^{31}$ == `-2147483648`。
> 为什么有符号数的最小值是这样表示呢？简而言之，无符号数的每一位都是正权值，而有符号数则不同，其符号位是**负权值**，剩余位是正权值。所以有符号数中，让符号位为 1、剩余位 全 0，就能得到最小的负数 `0x800000000`；让每一位都为 1，就能得到最大的负数 `-1 == 0xffffffff`。更多内容请阅读[这篇文章]({% post_url 2019-11-30-csapp-2 %}#整数表示)。  

### 总结

|  | 无符号数 Unsigned Int | 有符号数 Int |
| --- | --- | --- |
| 最大值  | `0xffffffff == 4294967295` | `0x7fffffff == 2147483647` |
| 0 | `0x00000000 == 0` | `0x00000000 == 0` |
| 最小值 | `0x00000000 == 0` | `0x80000000 == -2147483648` |

将无符号数、有符号数的最大值、最小值分别记为：UMax/UMin，TMax/TMin，可以看到有这样的关系：
```
TMin == -TMax - 1
```

## 在编程语言中表示最大、最小整数
这一节，我们以 C 语言和 Golang 为例，描述如何在编程语言中表示最大、最小整数。

### C 语言（32位）
无符号数的最大、最小值：
```c
unsigned int UMin = 0;

unsigned int UMax = ~0; // 1. 取反，让每一位为 1
unsigned int UMax = 0xffffffff; // 2. 或者直接写出十六进制补码表示
```

测试：
```c
printf("%#x, %u\n", UMin, UMin);
printf("%#x, %u\n", UMax, UMax);
```

输出：
```
0, 0
0xffffffff, 4294967295
```

有符号数的最大、最小值：
```c
int TMin = -TMax - 1; // 1. TMin = -TMax - 1
int TMin = 1 << 31; // 2. 移位。写成 -1 << 31 也可以
int TMin == 0x80000000; // 3. 直接写出十六进制补码表示

int TMax = ~TMin; // 1. 将 TMin 每一位取反
int TMax = 0x7fffffff; // 2. 直接写出十六进制补码表示
```

测试：
```c
printf("%#x, %d\n", TMin, TMin);
printf("%#x, %d\n", TMax, TMax);
```

输出：
```
0x80000000, -2147483648
0x7fffffff, 2147483647
```


### Go 语言（64位）
无符号数的最大、最小值：
```go
var UMin uint = 0

var UMax uint = ^uint(0)
var UMax uint = 0xffffffffffffffff // go 中 uint 是 64 位
```

测试：
```c
fmt.Printf("%#x, %d\n", UMin, UMin)
fmt.Printf("%#x, %d\n", UMax, UMax)
```

输出：
```
0x0, 0
0xffffffffffffffff, 18446744073709551615
```

有符号数的最大、最小值：
```c
var TMax int = int(UMax >> 1) 

var TMin int = -TMax - 1 
var TMin int = -1 << 63 // -(1 << 63) 也可以
var TMin int = -0x8000000000000000 // 要加负号
```

测试：
```c
fmt.Printf("%#x, %d\n", TMin, TMin)
fmt.Printf("%#x, %d\n", TMax, TMax)
```

输出：
```
-0x8000000000000000, -9223372036854775808
0x7fffffffffffffff, 9223372036854775807
```

## 深入了解
读者可能会有疑问：为什么 C 语言可以用 `0x80000000` 表示 TMin_32（`-2147483648`），但是 Go 语言就必须用 `-0x80000000` 来表示 TMin_32 呢？

实际上，在编译阶段，编译器会将十六进制数会被解释为一个无符号数（unsigned int）。因此 `0x80000000` 等于 `2147483648` == -TMin_32，而不是 TMin_32。

但是将一个无符号数赋给有符号数时，C 语言会做**隐式的类型转换**：
```c
int TMin = 0x80000000;
// 相当于
unsigned int a = 0x80000000;
int TMin = (int)a;
```

又因为 **int 与 unsigned int 之间的类型转换不改变位级表示**，只是换一种解释方法。因此无符号数 `0x80000000` 转为有符号数后，它的二进制表示没有变，只是将其作为**补码**来解释，值等于 `-2147483648` == TMin_32。

但是 Go 语言不会做这个隐式的类型转换，而是直接报错：
```go
var TMin int32 = 0x80000000 // Error: 0x80000000 (untyped int constant 2147483648) overflows int32
```

可以这样验证“位级表示不变”：
```c
// C 语言
int hcomp = (0x80000000 == 2147483648);
printf("%d\n", hcomp); // => 1
unsigned int a = 0x80000000;
int htmin = a; // 这里做了隐式类型转换
int hcomp2 = (htmin == -2147483648);
printf("%d\n", hcomp2); // => 1
```
```go
// Go 语言
var hcomp bool = (0x80000000 == 2147483648)
fmt.Println(hcomp) // => true
var a uint32 = 0x80000000
var htmin int32 = int32(a) // 这里要做显式的类型转换
var hcomp2 bool = (htmin == -2147483648)
fmt.Println(hcomp2) // => true
```

### 总结
无论是 Go 语言还是 C 语言，要表示 TMin_32，正确的方法就应该是 `-0x80000000`。如果用 `0x80000000` 来表示 TMin_32，C 语言会做一个隐式的类型转换，而 Go 语言会无法通过编译。

---

参考资料：
* [C语言中TMin的写法](https://www.cnblogs.com/jack47/archive/2013/01/06/tmin32-in-c.html)
