---
layout: post
title: 📔【深入理解计算机系统】第 2 章：信息的处理与表示
date: 2019/11/30 15:00
---

## 前言
* 三种编码方式：无符号、补码、浮点数。分别对应自然数、整数、实数
* 二进制的整数运算构成一个阿贝尔群，满足整数满足交换律、结合律等，可能溢出
* 浮点数不一定满足交换律，结合律，因为它只是近似表示

## 信息存储
### 存储单位
* 位（bit）：一个二进制位就是一比特
* 字节（byte）：8 位构成一个字节。计算机最小的可寻址的内存单位是字节，而不是单独的位
* 字（word）：2 个字节构成一个字
* 字长（word size）：**虚拟地址空间**的最大大小，也即“32 位、64 位”机器的含义。字长是指针数据的标称大小（nominal size），如 `char *` 类型的字节数就是 4（32 位机）或 8（64 位机）

### 变量大小
程序中声明的变量有不同的大小，如 int 是 4 字节、long 是 8 字节。这些变量在内存中按照 16 位**对齐**（一个 word）。这样硬件工作更高效。

指针变量的大小等于机器字长。

### 寻址和字节顺序
多字节对象连续存储，对象的地址是所使用字节的**最小地址**。如 4 字节的 int 变量，其地址是第一个字节的地址。

如前文所述，计算机最小的可寻址的内存单位是字节，而不是单独的位。换句话说，存储的时候**以字节为单位**而不是以位为单位。

按照有效字节在内存中的存储顺序，可以分为**大端法和小端法**：大端法从高到低，小端法从低到高。比如某十六进制的值 0x0123，存储在 0x100~0x101 的内存地址上。大端法存储为：`01 23`，小端法存储为 `23 01`。

### 布尔代数
#### 位级运算
取反 NOT(`~`)、与 AND(`&`)、或 OR(`|`)、异或 EXCLUSIVE-OR(`^`)。第一个是单目运算，其他都是双目运算。

#### 位运算的应用
位向量形如 `1110011010...`。可以使用位向量表示集合，与(&)和或(|)运算分别表示求并集和求交集。

与(&)实现掩码运算，从一个字中选出某些位。

异或，无需中间变量即可交换两个值：
```c
void inplace_swap(int x, int y) {
  y = x ^ y
  x = x ^ y // 前两步相当于：x = x ^ x ^ y = y
  y = x ^ y // 这一步相当于：y = y ^ x ^ y = x
}
```

异或还可以找出一堆数组中唯一的、只出现奇数次的数字。

### C 语言中的逻辑运算
与、或、非：&&、||、!

注意区分逻辑运算的与或非和位级运算的与或非（&、|、~)，二者完全不同：
1. 逻辑运算返回值只有 0 或 1
2. 逻辑运算是短路运算

### 移位操作
逻辑右移：左端补 0
算术右移：左端补符号位

移动 k 位、k 很大的时候，只会移动 `k mod w` 位，这里 w 是机器字长。如 32 位机器上，左移 40 位，只会执行左移 8 位。

## 整数表示
### 无符号数与有符号数（补码）
无符号数，二进制转为十进制：$B2U_w(X)=\sum^{w-1}_{i=0}{x_i2^i}$，其中 X 是一个数字的二进制表示，$x_i$ 是 X 的第 i 位。

有符号数采用**补码**表示。有符号数，二进制转为十进制：$B2U_w(X)=-x_{w-1}2^{w-1}+\sum^{w-2}_{i=0}{x_i2^i}$，其中 X 是一个数字的二进制表示，$x_i$ 是 X 的第 i 位。

有符号数的最高有效位就是**符号位**，其权重为 $-2^{w-1}$。而无符号数中，最高有效位的权重为$2^{w-1}$。

补码的取值范围：
* 最小值：$TMin_w=-2^{w-1}$，即 `1000...00`
* 最大值：$TMax_w=\sum^{w-2}_{i=0}{x_i2^i}$，即 `0111...11`

补码的范围是不对称的，**一半负数个数，一半非负数**，TMin 没有相对应的正数。比如 4 位补码的表示范围为 -8~7，对半分为 -8~-1，0~7。

### 为什么要用补码，而不是原码或者反码
原码最高位充当符号位，0 为正、1 为负。
反码最高位权值为 $-(2^{w-1}-1)$。
补码最高位权值为 $-2^{w-1}$。

原码和反码对于数字 0 都有两种不同的编码方式：原码有 +0 [000...0] 和 -0 [100...0]，反码有 +0 [000...0] 和 -0 [111...1]。

### 补码的术语来源
对于一个负数 -x，其二进制补码等同于：对于非负数 x，$2^w-x$ 的无符号表示。

### 有符号数与无符号数的转换
C 语言中，有符号数和无符号数比较时，有符号数会**隐式转换**为无符号数。

类型转换**不会改变位模式**，只会改变这些位的解释方式。

### 扩展与截断
扩展：左侧增加位，如 8 位数字扩展为 16 位数字。
截断：左侧截去位，如 16 位数字截断为 8 位数字。

* 无符号数的扩展：左侧增加 0  
* 补码数的扩展：左侧增加符号位

二者均能保持**值不变**。补码数如果是负数，新增加的符号位权值为 $-2^{k}$，而旧的符号位权值由 $-2^{k-1}$ 变为 $2^{k-1}$，**抵消**了增量。

截断就是丢弃高位。无论是无符号数还是补码数，在位级表示上都是一样的，都是去掉前几位。在位的解释上，一个解释成无符号数，一个解释成有符号数。

### 二者同时存在
先扩展位、再改变符号。比如从 short 转化为 unsigned 时，先扩展位大小，再有符号数转为无符号数。

## 整数运算
### 检测无符号数的加法溢出
两数相加，和小于任一加数。即 s=x+y，若 s<x（等价的，s<y），则溢出。

### 补码加法的溢出
* **负溢出**：两个负数相加，和比 TMin 还要小，发生负溢，最终结果变为正数
* **正溢出**：两个正数相加，结果比 TMax 还要大，发生正溢，最终结果变为负数

#### 检测补码加法的溢出
* 两个正数相加，得到负数，发生正溢出。  
* 两个负数相加，得到正数，发生负溢出。

### 补码的非
一个数的非就是它的相反数（逆元），两数相加为 0。

补码的非：如果 x > TMin，其补码的非为 -x；如果 **x == TMin，其补码的非为 x**。
> 设 x = TMin 的补码表示为 [111...1]，则 x + x = TMin + TMin = [111...1] + [111...1] = 1[000...0] = 0，前面溢出的 1 被丢弃了。

补码非的位级表示有两种。第一种是对每一位取反，再对结果加 1，表示为 C 语言式子：`-x == ~x+1`。

这种思路可以这样理解：对 x 每一位都取补，那么这个数和 x 加起来是 11111111…1；再将结果加 1，就会让其不断进位直到溢出，结果变为 0。因此按位取反再加 1 就是 x 的非。

另一种方法是找到补码位向量的最右边的 1 的位置，然后对其左边的所有位取反（不包括这个 1）。这种方法和第一种的思路其实是一致的。

### 补码加法、补码乘法
无论是加法还是乘法，无符号数和补码数的运算的**位级表示**都是一样的。一个将结果解释为无符号数，一个解释为有符号数。

### 检测乘法溢出
使用除法。见练习题 2.35

### 乘以常数 -> 移位和加法
当乘以一个常数时，编译器会使用移位和加法运算的组合来代替乘以常数。

比如 `x*14`，由于 $14=2^3+2^2+2^1$，所以会将乘法重写为 `(x<<3)+(x<<2)+(x<<1)`；还可以利用 $14=2^4-2^1$，将其改写为 `(x<<4)-(x<<1)`。

### 除以 2 的幂 / 模运算
无符号和补码数分别使用逻辑移位和算术移位代替除以 2 的幂。

整数除法需要**向 0 舍入**。无符号数和补码的移位运算都是向负无穷舍入。无符号数由于数值非负，因此等同于是向 0 舍入。补码数在数组为正时，等同于向 0 舍入；数值为负时，却是向负无穷舍入，导致结果不准确。

解决方法是**增加一个 bias**。如果被除数是负数，那么需要加上一个偏置来向上舍入。偏置是 `2^k-1`。

C 语言中，数字都是用补码表示。在除法运算时，编译器会自动地增加这个偏置。C 表达式：
```c
(x<0 ? x+(1<<k)-1 : x) >> k
```
会计算数值 $x/2^k$。

## 浮点数
### IEEE 浮点表示
公式表示：$V=(-1)^s×M×2^E$
* 符号位 s(sign)：正数还是负数
* 尾数 M(significand)：二进制小数
* 阶码 E(exponent)：对浮点数加权

编码表示：将浮点数的位分为三个字段
* 符号位 1 位，直接编码符号 s
* k 位阶码字段 exp 编码阶码 E。注意 exp **不等于** E，E 等于 `e-Bias` 或者 `1-bias`，见下文
* n 位小数字段 frac 编码尾数 M，同样编码出来的值**不一定**等于 M，依赖于阶码字段的值 exp 是否为 0

根据 exp 的值，被编码的值可以分为 3 种不同情况：
* 规格化的：阶码不全 0、不全 1
    * 阶码的值被解释以偏置形式表示的有符号整数，阶码字段 exp 表示的指数为 E=e-Bias，其中 e 是 k 位阶码字段表示的无符号数，Bias 等于 $2^{k-1}-1$
    * 小数字段 frac 表示的尾数为 M=1+f，f 为小数字段表示的小数值，尾数**隐含的以 1 开头**
* 非规格化的：阶码全 0
    * 解码值是 E=1-Bias。不设置为 -Bias 是为了获得平滑的过渡
    * 尾数 M=f，不包含隐含的 1
    * 数值 0 可以表示为除符号位以外全是 0，这样有正 0 和负 0
* 特殊值：阶码全 1
    * 阶码全 1、尾数全 0：无穷大
    * 阶码全 1、尾数不为 0：NaN，not a number

浮点数分类：
![15751032439909](/media/15751032439909.jpg)


### 浮点数表示示例
6 位 浮点数示例：
![15751036989967](/media/15751036989967.jpg)


8 位浮点数的非负值示例，可以看到最大的非规格化数和最小的规格化数之间的平滑过渡：
![15751038137166](/media/15751038137166.jpg)


### 浮点数比较大小
将浮点数的位级表示看作无符号数，直接比较。负数需要简单的额外处理。

### 浮点运算
浮点加法不具有结合性，因为可能溢出、丢失精度。  

乘法同理，可以交换，不可以结合，也不具有分配性。但是乘法运算满足**单调性**，即只要a、b、c≠NaN，那么如果 a≥b，就一定有 `a*c≥b*c`。

### 浮点数与整数的类型转换
int 是 32 位，float 的尾数位是 23 位，double 的尾数位是 52 位。

* int → float：不会溢出，可能丢失精度
* int/float → double：不会变
* double → float：可能溢出，也可能丢失精度
* float → double/int：值会向 0 舍入。这相当于把尾数位看作无符号数，丢弃掉多余的位
